---
layout: post
title: "Scorpio RPG Kit I: 概览"
description:
  这个系列将带你了解Scorpio——专为虚幻引擎5打造的RPG开发套件——背后的架构设计思路。
date: 2025-01-03 13:15 +0800
categories: [Unreal, Gameplay]
published: true
tags: [Unreal, Gameplay, Plugin]
media_subpath: /assets/img/post-data/unreal/gameplay/scorpio/
lang: zh-CN
---

> 2025年更新：本系列将暂时停更，因为我发现现有架构有些过时，不符合现代UE5架构规范。（更准确地说，我造了和UE5一样的轮子，但是Epic实现的比我好的多）
{: .prompt-warning }

{% include ue_version_disclaimer.html version="5.4.0" %}

## 引言

`Scorpio`是专为虚幻引擎5打造的`RPG`开发套件。核心系统架构由我独立完成，其中任务对话系统是基于[Narrative 3]的魔改版本（注意：`Scorpio`并不依赖`Narrative 3`插件，我是买了插件后手动整合进自己架构的）。由于授权问题，`Scorpio`不会开源，它是我为自己游戏项目打造的开发框架。

既然不开源为什么要写这个系列呢？因为在开发过程中，这套架构帮我节省了大量时间和精力，所以想分享背后的设计思路、踩坑经验、解决方案和代码片段。如果能给独立开发者们带来灵感，或者收获改进建议就更好了！

## 开发动机
网上充斥着各种"20分钟打造战斗系统"这类基础（甚至粗糙）的教程，虽然适合新手快速理解概念，但根据我的经验，这些方案几乎没人敢用在正式项目中。

最大的问题是什么？架构设计！我们经常看到炫酷的商城插件就买来用，结果发现和现有系统水土不服。更常见的是，为了某个小功能不得不引入包含上百个功能的插件。这就像打开传送门邀请各路模块随意入侵——初期觉得可控，但随着不兼容的系统/插件越来越多，项目很快就会变成难以维护的烂摊子。很多项目因此胎死腹中。

所以本系列会更关注架构设计和决策思路，而不仅是实现方法。当然我的方案未必完美，但希望能抛砖引玉，引发更多讨论。

>经典困境: 插件A把核心逻辑写在`GameInstance`里，但我们的项目已经有自己的`GameInstance`了。现在要么把插件A的逻辑复制粘贴到我们的版本，然后手动修改所有蓝图引用；要么把我们的逻辑合并到插件A的版本。结果发现插件B/C/D/E...全都在`GameInstance`里写逻辑...救命啊！
{: .prompt-info}

## 项目目标
打造通用型虚幻引擎RPG框架，解决以下痛点：
- **可复用性**: 模块化设计，即插即用支持各类RPG游戏
- **可扩展性**: 新增功能不影响现有系统
- **集中管理**: 各项目可贡献通用改进，所有项目都能受益
- **简化复杂度**: 封装存档、背包、任务、对话、角色、技能等通用模块
- **快速迭代**: 游戏逻辑模块化，支持快速拼装新玩法
- **降低成本**: 为RPG类独立游戏提供坚实基础，降低边际成本

## 与虚幻引擎的关系
从功能层级看：
- 底层是虚幻引擎：提供游戏开发基础功能，不限定具体类型
- 中间层是`Scorpio`：专注RPG类型的开发框架（当然你也可以扩展它做赛车/FPS游戏）
- 上层是具体游戏项目：基于`Scorpio`框架开发，无需修改核心代码即可扩展功能

![Scorpio Kit](scorpio_relationship.png){: width="500"}
_Scorpio Kit Relationship Diagram_

## 版本控制结构
当前采用流映射(`stream mapping`)的版本控制结构，所有游戏项目直接共享`Scorpio`主分支（未来项目增多时会为每个项目创建独立分支）。

![Scorpio Kit](scorpio_p4relationship.png){: width="500"}
_Scorpio Kit Perforce Relationship Diagram_

这种结构的优点是：
- 任何改进/修复都能即时同步到所有项目
- 集中管理所有通用功能改进
- 未来可以拆分为多模块，按需选用

>注意：多人协作时这种结构可能造成意外变更污染，但目前我是独立开发所以没关系。如果未来需要，可以增加流映射层级来解决——每个项目先提交到自己的`Scorpio`分支，经过审核后再合并到主分支。
{: .prompt-danger}

## 功能范围
当前`Scorpio`已实现以下功能（按优先级排序）：

### 核心功能
这些是保证`Scorpio`其他系统正常运转的核心功能：
- 自动存档与读取
  - 当玩家开门、进入房间或啃苹果时，其实是在和游戏世界互动——这些数据必须被保存和读取，否则游戏体验就变成"一次性用品"了。`Scorpio`会努力帮你搞定这些琐事。
- Message Bus
  - 当玩家进入某个区域时，往往有一堆系统需要知道这事儿。但让蓝图处理会导致代码高度耦合，而让每个系统监听事件又会让它们和具体区域对象绑死。其实大家只关心"进出区域"这个行为本身，所以不如用`Message Bus`传递信息，让系统们优雅地隔空聊天~
- 运行时常量数据
  - 随时待命的常量数据，加载后常驻内存供各系统快速调用，避免运行时卡顿。
- 基于宏的代码自动生成
  - 为管理器和可序列化数据生成模板代码，既加速开发迭代，又减少手误翻车。
- 静态工具函数集
  - 全项目通用的工具函数合集，比如数学计算的封装等，随取随用。

### 资源管理
这些数据资产构成了游戏世界与配置：
- 角色
  - 玩家和NPC都有自己的角色数据，底层项目可自由扩展
- 角色日程表
  - 让NPC拥有自己的作息规律
- 交互设置
  - 定义玩家能否/如何与物体互动
- 区域
  - 标记玩家进出区域（一个区域可包含多个场景，通常同区域场景会同时加载/卸载）
- 场景
  - 标记玩家进出具体场景
- Persistent Flag
  - 简易`Persistent Flag`，可用于任意需要存档的数据（比如玩家是否看过某过场动画）。注意：对话/任务等有独立存档系统，这个更适合游戏特有的灵活需求。
- 奖励 & 奖励组
  - 单个奖励可包含物品或属性，奖励组则打包多个奖励方便复用
- 商人
  - 任何NPC都能变身商人，只需配置可售卖物品列表
- 任务
  - 基于有限状态机（FSM）的任务系统
- 对话
  - 基于有限状态机（FSM）的对话系统

### Gameplay
这些构建在核心系统之上的玩法模块，主要负责操作上述数据资产：
- 自定义时间类
  - 用`YYYY-MM-DD`格式表示日期，并划分时段（早晨/正午/下午等）。虽然设计偏项目特定，但不需要的项目可以轻松封装转换——比如想模拟时分秒的游戏，只需映射时段即可。
  - 时间还能计算"年龄"（比如"玩家上次和NPC聊天是多久前"），当前框架已内置现实世界的月份规则（知道1月有31天，2月要特殊处理等）。
- 交互系统
  - 处理玩家与物体的互动：支持复杂前提条件（比如"玩家必须拿着钥匙+和NPC聊过天+3天前的夜晚去过海滩"）和后续动作（比如"宝箱每天只能开一次"），所有状态都会自动持久化存档。
  - 包含多种交互状态：完全不可交互（无UI反馈）、已锁定（显示需求提示）、今日已交互等。
- 镜头管理器
  - 作为中央枢纽管理镜头实例，轻松混合玩家控制镜头和事件镜头
- 技能管理器
  - 技能树系统，玩家解锁技能时会通过`FGameplayTag`与`GAS`（游戏技能系统）联动应用效果
- 背包管理器
  - 物品收集系统，每个物品可具备以下特性： 
    - 使用：触发游戏效果
    - 赠送：赠予NPC时触发效果
    - 出售
    - 丢弃
    - 装备：持续生效直到卸下
- 角色状态管理器
  - 为所有角色创建代理Actor来管理状态，这样即使角色不在当前场景也能操作其数据
- 游戏流程管理器
  - 监控游戏状态（前端界面/事件中/小游戏/对话/自由探索），掌管游戏时间流动。还能维护两套时间线（真实时间+事件时间）来实现"回忆杀"效果
- 地图管理器
  - 负责地图流式加载与层级管理
- 叙事管理器
  - 追踪任务与对话状态，所有开始/完成任务/对话的请求都通过该管理器API调用
- 通知管理器
  - 统一处理通知请求，由HUD排队播放并决定视觉效果（比如消息堆叠逐条显示）
- 持久化管理器
  - 管理交互记录等与场景实例相关的状态，自动处理存档。任何需要持久化的自定义数据也可注册到这里托管

### 模块化玩法
这些即插即用的模块能快速组合出新玩法：
- 游戏事件
  - 像"请求UI"/"开启任务"这样的一次性事件，任何系统都可触发
- 游戏条件
  - 像"玩家是否在区域"/"是否持有物品"这样的条件判断，任意系统都可调用
- 游戏任务
  - 像"抵达某地"/"收集物品"这样的持续性任务，由任务系统监控直到完成或失败

### 世界构建工具
快速填充游戏内容的实用工具：
- Spline Actor
  - 快速生成沿Spline分布的Actor（比如路边石、河流等）
- Procedural Floor Actor
  - 快速铺设网格状Actor（适合城市广场等场景，当然也能用来修路）

### UI & 反馈
这些是HUD界面上的UI和反馈系统，包括消息、通知以及与其他系统协作的协议：
- 通知小部件
  - 通知小部件用于处理来自通知管理器的消息，它更像一个演示用的组件，游戏项目可以轻松扩展它。
- 模块化UI & 堆栈
  - 一套模块化UI系统，封装了从富文本、按钮、窗口到更复杂组件的各种基础UI元素。举个实用例子：任何系统都可以调用API来请求一个确认界面（一个带文字和“是/否”按钮的窗口，附带回调系统），并确保游戏内的视觉和操作保持一致。

### 音频系统
提供音频管理器作为中央枢纽，用于动态混音和管理不同总线的音频：
- 声音管理器
  - 一个可以作为中央枢纽的声音管理器，用于请求音频实例及其对应总线，并由管理器进行混音和动态调整音量。

### 渲染
- 通用UI Shader库
- 通用后处理Shader库

## 限制说明
当然目前这个项目也有一些小限制：

### 网络功能
目前由于工作量问题，暂无网络支持计划，但架构设计并未阻止未来添加该功能。（我们需要实现服务端网络枢纽来序列化和传输网络事件，以及客户端网络枢纽来处理它们。之所以需要手动实现，是因为该框架的核心驱动是 UObject，而它原生不支持网络同步——底层项目也需要自行实现网络相关逻辑。）

### 动画
`Scorpio` 不会提供任何动画资产或动画蓝图，这部分内容高度依赖具体项目，很难做出通用方案。何况虚幻引擎本身已经内置了非常强大的动画系统。

### 最终视觉效果
`Scorpio` 仅提供UI和姿势处理的实用着色器，不会提供任何可直接用于生产的视觉资产或材质——原因同上，这些内容高度项目定制化，通用方案难以实现。何况虚幻引擎本身已经内置了极其强大的渲染系统。

### 输入与控制
同上，这部分高度依赖项目需求，很难做通用方案。何况虚幻引擎本身就有完善的输入控制系统。

## 旅程开始
从下一篇文章起，我们将深入探讨 `Scorpio` 的具体实现细节。敬请期待！

[Narrative 3]: https://www.fab.com/listings/e3f81dd7-e00b-4c32-ba52-a366145b2ae6